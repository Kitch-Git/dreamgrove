import { SpellInfo, Cast, SpellTimeline } from '../../lib/types/cd_planner'

/**
 * Direction of the effect - either modifying the start or end time
 */
export type EffectDirection = 'start' | 'end'

/**
 * Effect to apply to a spell or cast
 */
export interface Effect {
  direction: EffectDirection
  value: number
}

/**
 * Patch to apply to all instances of a specific spell
 */
export interface SpellPatch {
  spellId: number
  effect: Effect
}

/**
 * Patch to apply to a specific cast instance
 */
export interface CastPatch {
  castId: string
  effect: Effect
}

/**
 * A collection of patches generated by a timeline effect
 */
export interface Patch {
  effectId: string
  spellPatches: SpellPatch[]
  castPatches: CastPatch[]
}

/**
 * Apply a single effect's patches to a collection of spell casts
 */
export function applyPatch(spellCasts: SpellTimeline[], patch: Patch): SpellTimeline[] {
  // Create a deep copy to avoid mutating the original
  const result = JSON.parse(JSON.stringify(spellCasts)) as SpellTimeline[]

  // Apply spell patches - these affect all casts of a specific spell
  if (patch.spellPatches.length > 0) {
    patch.spellPatches.forEach((spellPatch) => {
      // Find spells that match the spellId
      result.forEach((spellCast) => {
        if (spellCast.spell.spellId === spellPatch.spellId) {
          spellCast.casts = spellCast.casts.map((cast) => {
            return applyEffectToCast(cast, spellPatch.effect)
          })
        }
      })
    })
  }

  // Apply cast patches - these affect specific cast instances
  if (patch.castPatches.length > 0) {
    patch.castPatches.forEach((castPatch) => {
      // Find the specific cast by ID
      result.forEach((spellCast) => {
        const castIndex = spellCast.casts.findIndex((cast) => cast.id === castPatch.castId)
        if (castIndex !== -1) {
          // Apply patch to this specific cast
          spellCast.casts[castIndex] = applyEffectToCast(
            spellCast.casts[castIndex],
            castPatch.effect
          )
        }
      })
    })
  }

  return result
}

/**
 * Apply multiple patches in sequence to a collection of spell casts
 */
export function applyPatches(spellCasts: SpellTimeline[], patches: Patch[]): SpellTimeline[] {
  if (patches.length === 0) {
    return spellCasts
  }

  // Sort patches by effectId to ensure consistent application order
  const sortedPatches = [...patches].sort((a, b) => a.effectId.localeCompare(b.effectId))

  // Start with a deep copy of the input spells to avoid mutation
  let result = spellCasts

  for (const patch of sortedPatches) {
    result = applyPatch(result, patch)
  }

  return result
}

/**
 * Apply an effect to a single cast
 */
function applyEffectToCast(cast: Cast, effect: Effect): Cast {
  const result = { ...cast } as Cast

  if (effect.direction === 'start') {
    // Modify the start time
    result.start_s = cast.start_s + effect.value
    // Ensure start time doesn't go below 0
    if (result.start_s < 0) {
      result.start_s = 0
    }
  } else if (effect.direction === 'end') {
    // For the end time, we need to modify the underlying value that affects end_s
    // Since end_s is calculated as start_s + channel_duration_s, we need to modify channel_duration_s
    // result.channel_duration_s = Math.max(0, cast.channel_duration_s + effect.value)
  }

  return result
}

/**
 * Debug utility to print information about patches
 */
export function logPatchInfo(patches: Patch[]): void {}
