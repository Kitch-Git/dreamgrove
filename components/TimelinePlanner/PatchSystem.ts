import { SpellInfo, CastInfo, SpellCasts } from './types'

/**
 * Direction of the effect - either modifying the start or end time
 */
export type EffectDirection = 'start' | 'end'

/**
 * Effect to apply to a spell or cast
 */
export interface Effect {
  direction: EffectDirection
  value: number
}

/**
 * Patch to apply to all instances of a specific spell
 */
export interface SpellPatch {
  spellId: number
  effect: Effect
}

/**
 * Patch to apply to a specific cast instance
 */
export interface CastPatch {
  castId: string
  effect: Effect
}

/**
 * A collection of patches generated by a timeline effect
 */
export interface Patch {
  effectId: string
  spellPatches: SpellPatch[]
  castPatches: CastPatch[]
}

/**
 * Apply a single effect's patches to a collection of spell casts
 */
export function applyPatch(spellCasts: SpellCasts[], patch: Patch): SpellCasts[] {
  // Create a deep copy to avoid mutating the original
  const result = JSON.parse(JSON.stringify(spellCasts)) as SpellCasts[]

  // Apply spell patches - these affect all casts of a specific spell
  if (patch.spellPatches.length > 0) {
    console.log(`Applying ${patch.spellPatches.length} spell patches from effect ${patch.effectId}`)
    patch.spellPatches.forEach((spellPatch) => {
      // Find spells that match the spellId
      result.forEach((spellCast) => {
        if (spellCast.spell.spellId === spellPatch.spellId) {
          console.log(`  Patching spell: ${spellCast.spell.name} (${spellCast.spell.spellId})`)
          // Apply patch to all casts of this spell
          spellCast.casts = spellCast.casts.map((cast) => {
            return applyEffectToCast(cast, spellPatch.effect)
          })
        }
      })
    })
  }

  // Apply cast patches - these affect specific cast instances
  if (patch.castPatches.length > 0) {
    console.log(`Applying ${patch.castPatches.length} cast patches from effect ${patch.effectId}`)
    patch.castPatches.forEach((castPatch) => {
      // Find the specific cast by ID
      result.forEach((spellCast) => {
        const castIndex = spellCast.casts.findIndex((cast) => cast.id === castPatch.castId)
        if (castIndex !== -1) {
          console.log(
            `  Patching specific cast: ${castPatch.castId} of spell ${spellCast.spell.name}`
          )
          // Apply patch to this specific cast
          spellCast.casts[castIndex] = applyEffectToCast(
            spellCast.casts[castIndex],
            castPatch.effect
          )
        }
      })
    })
  }

  return result
}

/**
 * Apply multiple patches in sequence to a collection of spell casts
 */
export function applyPatches(spellCasts: SpellCasts[], patches: Patch[]): SpellCasts[] {
  // If there are no patches, return a deep copy of the input to avoid mutation
  if (patches.length === 0) {
    console.log('No patches to apply, returning copy of input spells')
    return JSON.parse(JSON.stringify(spellCasts))
  }

  // Sort patches by effectId to ensure consistent application order
  const sortedPatches = [...patches].sort((a, b) => a.effectId.localeCompare(b.effectId))

  console.log(`Applying ${patches.length} patches in sequence`)

  // Start with a deep copy of the input spells to avoid mutation
  let result = JSON.parse(JSON.stringify(spellCasts))

  // Apply each patch in sequence
  for (const patch of sortedPatches) {
    result = applyPatch(result, patch)
  }

  return result
}

/**
 * Apply an effect to a single cast
 */
function applyEffectToCast(cast: CastInfo, effect: Effect): CastInfo {
  const result = { ...cast }

  if (effect.direction === 'start') {
    // Modify the start time
    const oldStart = result.start_s
    result.start_s = cast.start_s + effect.value
    // Ensure start time doesn't exceed end time
    if (result.start_s > result.end_s) {
      result.start_s = result.end_s
    }
    console.log(
      `    Adjusted cast start time: ${oldStart} -> ${result.start_s} (${effect.value > 0 ? '+' : ''}${effect.value}s)`
    )
  } else if (effect.direction === 'end') {
    // Modify the end time
    const oldEnd = result.end_s
    result.end_s = cast.end_s + effect.value
    // Ensure end time isn't before start time
    if (result.end_s < result.start_s) {
      result.end_s = result.start_s
    }
    console.log(
      `    Adjusted cast end time: ${oldEnd} -> ${result.end_s} (${effect.value > 0 ? '+' : ''}${effect.value}s)`
    )
  }

  return result
}

/**
 * Debug utility to print information about patches
 */
export function logPatchInfo(patches: Patch[]): void {
  console.log(`----- Patch Debug Information -----`)
  console.log(`Total Patches: ${patches.length}`)

  patches.forEach((patch, index) => {
    console.log(`Patch #${index + 1}: ${patch.effectId}`)
    console.log(`  Spell Patches: ${patch.spellPatches.length}`)
    patch.spellPatches.forEach((spellPatch) => {
      console.log(
        `    SpellID: ${spellPatch.spellId}, Direction: ${spellPatch.effect.direction}, Value: ${spellPatch.effect.value}`
      )
    })

    console.log(`  Cast Patches: ${patch.castPatches.length}`)
    patch.castPatches.forEach((castPatch) => {
      console.log(
        `    CastID: ${castPatch.castId}, Direction: ${castPatch.effect.direction}, Value: ${castPatch.effect.value}`
      )
    })
  })

  console.log(`----- End Patch Debug Information -----`)
}
