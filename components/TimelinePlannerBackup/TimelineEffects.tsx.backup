import { SpellInfo, CastInfo, SpellCasts, TimelineEffect } from './types'
import { Patch, applyPatches, logPatchInfo } from './PatchSystem'

// Force of Nature IDs - for use in effects
const FORCE_OF_NATURE_IDS = [205636, 'force_of_nature']

// Export the collection of timeline effects
export const timelineEffects: TimelineEffect[] = [
  {
    id: 'control_of_dream',
    name: 'Control of the Dream',
    description: 'Reduces cooldown of Celestial Alignment/Incarnation by 15s',
    applyEffect: (currentSpells: SpellCasts[], availableSpells: SpellInfo[]) => {
      // Legacy implementation - kept for backward compatibility
      return currentSpells
    },
    generatePatch: (currentSpells: SpellCasts[], availableSpells: SpellInfo[]): Patch | null => {
      // Don't generate patch if no spells
      if (currentSpells.length === 0) return null

      // Create a patch for the Control of the Dream effect
      const patch: Patch = {
        effectId: 'control_of_dream',
        spellPatches: [],
        castPatches: [],
      }

      // Find Celestial Alignment or Incarnation spells
      const targetSpells = currentSpells.filter((spellCasts) => {
        const spellName = spellCasts.spell.name.toLowerCase()
        return spellName.includes('celestial alignment') || spellName.includes('incarnation')
      })

      // For each target spell, create cast-specific patches
      targetSpells.forEach((spellCasts) => {
        // Sort casts by start time to ensure correct ordering
        const sortedCasts = [...spellCasts.casts].sort((a, b) => a.start_s - b.start_s)
        console.log('sortedCasts', sortedCasts)

        // Apply reductions and track the actual adjusted end times
        const adjustedEndTimes = new Map<string, number>()

        // Apply 15s reduction to the first cast if it exists
        if (sortedCasts.length > 0) {
          const firstCast = sortedCasts[0]
          const firstCastReduction = 15

          patch.castPatches.push({
            castId: firstCast.id,
            effect: {
              direction: 'end',
              value: -firstCastReduction, // Apply 15s reduction to first cast
            },
          })

          // Store the adjusted end time for the first cast
          adjustedEndTimes.set(firstCast.id, firstCast.end_s - firstCastReduction)
        }

        // Process all casts except the first one
        for (let i = 1; i < sortedCasts.length; i++) {
          const thisCast = sortedCasts[i]
          const previousCast = sortedCasts[i - 1]

          // Use the adjusted end time for the previous cast if available
          const previousEndTime = adjustedEndTimes.get(previousCast.id) ?? previousCast.end_s

          // Calculate reduction value - the minimum of 15s or the time between this cast's start and previous cast's adjusted end
          const reductionValue = Math.min(15, thisCast.start_s - previousEndTime)

          // Only create a patch if there's a meaningful reduction
          if (reductionValue > 0) {
            patch.castPatches.push({
              castId: thisCast.id,
              effect: {
                direction: 'end',
                value: -reductionValue, // Negative value to reduce cooldown
              },
            })

            // Store the adjusted end time for this cast
            adjustedEndTimes.set(thisCast.id, thisCast.end_s - reductionValue)
          } else {
            // Even if no reduction is applied, store the original end time
            adjustedEndTimes.set(thisCast.id, thisCast.end_s)
          }
        }
      })

      return patch.castPatches.length > 0 ? patch : null
    },
  },
  {
    id: 'stack_cds',
    name: 'Stack Cooldowns',
    description: 'Move cooldowns to align with major CDs',
    applyEffect: (currentSpells: SpellCasts[], availableSpells: SpellInfo[]) => {
      // Legacy implementation - kept for backward compatibility
      return currentSpells
    },
    generatePatch: (currentSpells: SpellCasts[], availableSpells: SpellInfo[]): Patch | null => {
      // This would involve more complex logic to identify major CDs and align others
      // For now, returning null to indicate no modifications
      return null
    },
  },
  {
    id: 'force_of_test',
    name: 'Force of Test',
    description: 'Reduces cooldown of Force of Nature by 10s',
    applyEffect: (currentSpells: SpellCasts[], availableSpells: SpellInfo[]) => {
      // Legacy implementation - just return currentSpells without modification
      // This is now handled by generatePatch and applied through the patch system
      console.log('Force of Test legacy applyEffect called - using patch system instead')
      return currentSpells
    },
    generatePatch: (currentSpells: SpellCasts[], availableSpells: SpellInfo[]): Patch | null => {
      // Don't generate patch if no spells
      if (currentSpells.length === 0) return null

      // Create a patch for Force of Test effect
      const patch: Patch = {
        effectId: 'force_of_test',
        spellPatches: [],
        castPatches: [],
      }

      // Find Force of Nature spells
      currentSpells.forEach((spellCasts) => {
        const isForceOfNatureSpell =
          FORCE_OF_NATURE_IDS.includes(spellCasts.spell.id) ||
          spellCasts.spell.name.toLowerCase().includes('force of nature')

        if (isForceOfNatureSpell) {
          console.log('Found Force of Nature spell:', spellCasts.spell.name)

          // Add spell patch to reduce duration/cooldown
          patch.spellPatches.push({
            spellId: Number(spellCasts.spell.spellId),
            effect: {
              direction: 'end',
              value: -10, // Reduce cooldown by 10 seconds
            },
          })
        }
      })

      return patch.spellPatches.length > 0 ? patch : null
    },
  },
]

// Helper function to check if a spell is Force of Nature
export const isForceOfNature = (spellId: string | number): boolean => {
  return FORCE_OF_NATURE_IDS.includes(spellId)
}

// Generate patches from active effects
export const generatePatches = (
  activeEffects: string[],
  currentSpells: SpellCasts[],
  spells: SpellInfo[]
): Patch[] => {
  const patches: Patch[] = []

  // Ensure no patches are created for effects that are not active
  // This is already happening correctly by only iterating over activeEffects
  activeEffects.forEach((effectId) => {
    const effect = timelineEffects.find((e) => e.id === effectId)
    if (effect && effect.generatePatch) {
      const patch = effect.generatePatch(currentSpells, spells)
      if (patch) {
        patches.push(patch)
      }
    }
  })

  // Log patch information for debugging
  if (patches.length > 0) {
    logPatchInfo(patches)
  } else {
    console.log('No patches generated from active effects')
  }

  return patches
}

// Helper function to apply multiple effects to spells
export const applyTimelineEffects = (
  currentSpells: SpellCasts[],
  activeEffects: string[],
  spells: SpellInfo[]
): SpellCasts[] => {
  // Generate patches from active effects
  const patches = generatePatches(activeEffects, currentSpells, spells)

  console.log('Current spells:', currentSpells)

  // Log each time effects are applied to help with debugging
  console.log(`Applying ${patches.length} patches from ${activeEffects.length} active effects`)

  // Apply patches to get the modified spells - always pass through applyPatches
  // This ensures a consistent non-destructive approach
  return applyPatches(currentSpells, patches)
}
